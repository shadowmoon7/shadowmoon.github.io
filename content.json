{"pages":[],"posts":[{"title":"AG273QXP开箱体验","text":"最近到手一款显示器AOC AG273QXP，顺便来做个开箱。首先感谢显示器的提供者@心弦数码科技，最近感冒没法做开箱视频，就写篇文章记录一下整个过程和个人体验。 外观 箱子很大，里面带了个遮光板，内部带绒。主要配件电源线、DP线(据说是1.2的)、USB上行线，用来扩展USB接口，其它配件有2个束线夹和4个螺柱（忘了拍），可以壁挂。 嗯，遮光罩在一定程度上提升了这款显示器的b格。 背部是散热和RGB灯效果，有诸多效果可选。正面看不到，后面都是墙，再上一个遮光罩…… 显示器推到最高，可以竖屏，应该是这个价位的标配，用来看java调用栈是足够了。 旋转成竖屏的时候左侧就能看到各种接口，由上到下依次是miniUSB人机接口，耳机口、2个DP口（据说官方送的线是DP1.2的，1.4需要自己买线）、2个HDMI口、摇杆菜单、电源插口、2个USB口（黄色的支持快充）和USB上行接口，接口倒是挺丰富的，摇杆菜单很好用。 参数 参数的话我找了个up主的恰饭视频，应该比较官方。这款显示器主打电竞方面，由于不太打游戏，直接看看官方参数就好。 个人体验 好了好了，听官方吹完了，说说实际体验。 组装很方便，支架太大，破坏整体颜值。屏幕四周有些许漏光，据说这是IPS屏的通病。就像孙悟空再怎么也逃不出如来佛的手掌心😂。右侧的挂耳机/钥匙的小挂杆很好用。 窄边框好评，屏幕色彩艳丽，整体泛红，可能用惯了垃圾显示器，竟然觉得太刺眼。简单调整方案：冷色调+亮度20+对比度20。终极解决方案：需要校色，据说校色后效果会好很多，后面校完色放一下前后对比图。非原生10bit，8抖10，网上吐槽比较多的是不能165 2k 10bit hdr同时开，有一个升级款AG273QXD可以全开。 大支架+27英寸，嗯~买之前确保你有一张比较大的桌子😜，日常使用离眼睛屏幕最少伸开手指一臂，不然累得慌。嗯，这更凸显了大桌子的重要性哈哈哈 基本体验就这些，后面有什么再补充。","link":"/2020/12/AG273QXP%E5%BC%80%E7%AE%B1%E4%BD%93%E9%AA%8C/"},{"title":"Java问题排查","text":"这是一些 java 程序查错的方法和经常使用的命令。 排查业务问题 采用tail -fn 200 log_file实时查询线上日志 找准日志搜索关键字 keyWord，例如 orderid、mobileId、reqId 等 采用grep keyWord log_file查询关键字所在行的日志 采用 grep -C n keyWord log_file匹配关键字所在行的上下 n 行 采用grep keyWord log_file | wc -l匹配关键字的行数有多少 根据实际排查日志场景进行搜索 tail、grep 用的最多 线上应用 CPU 占用过高 采用top命令，找出 CPU 占用最高的 PID 通过ps -ef | grep PID查看对应的应用 采用jstack -l PID &gt;&gt; PID.log获取进程额堆栈信息 采用ps -mp PID -o THREAD,tid,time拿到占用 CPU 最高的 tid 采用printf “%x\\n” tid获取 16 进制的线程 TID 采用grep TID -A20 PID.log确定是线程哪里除了问题 腿疼医腿，辩证施治，对症下药，找准代码位置，进行调整代码 线上应用内存溢出 采用top命令，找出对应的 PID 采用jmap -heap PID确认一下分配的内存少不少 采用jmap -histo:live PID | more找出分析最耗内存的对象 采用ps -efL | grep PID | wc -l查看进程创建的线程数 采用ls -l /proc/PID/task | wc -l也可以查看进程创建的线程数 采用netstat -apn | grep 4532 | wc -l查看进程网络连接数 腿疼医腿，辩证施治，对症下药 a. 内存分配确实小，适当调整内存； b. 对象被频繁创建，且不释放，优化代码； c. 不断创建线程或者不断进行网络连接，优化代码。 性能问题排查思路 设计调优：一个良好的系统设计可以规避很多钱在的性能问题。必须熟悉常用的软件设计方法、设计模式、基本性能组件和常用优化思想。 代码调优：掌握编码技巧、对算法、数据结构的灵活使用。 JVM 调优：JVM 的各项参数会直接影响 Java 程序的性能。 数据库调优：在应用层对 SQL 语句进行优化；对数据库进行优化。 操作系统调优：操作系统的性能对应用系统也有较大影响。 腿疼医腿，辩证施治，对症下药。","link":"/2020/04/Java%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"title":"Markdown语法测试","text":"测试一下看 Markdown 的语法支持的怎么样，取自 Cmd Markdown 的语法介绍。 1. 斜体和粗体 使用 * 和 ** 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题 使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接 使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表 使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表 使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用 使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块 使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块 使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像 使用 ![描述](图片链接地址) 插入图像。 示例： Cmd Markdown 高阶语法手册 1. 内容目录 在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类 在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线 使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚 使用 [^keyword] 表示注脚。 这是一个注脚[1]的样例。 这是第二个注脚的样例。 5. LaTeX 公式 $ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 E=mc2E=mc^2E=mc2 来表达。 $$ 表示整行公式： ∑i=1nai=0\\sum_{i=1}^n a_i=0 i=1∑n​ai​=0 f(x1,xx,…,xn)=x12+x22+⋯+xn2f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 f(x1​,xx​,…,xn​)=x12​+x22​+⋯+xn2​ ∑k=0j−1γ^kjzk\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k} k=0∑j−1​γ​kj​zk​ 访问 MathJax 参考更多使用方法。 6. 加强的代码块 支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) { var a = 1, b = 1; var tmp; while (--n &gt;= 0) { tmp = a; a += b; b = tmp; } return a;}document.write(fib(10)); 7. 流程图 示例 12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考 8. 序列图 示例 1 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 2 12345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考 9. 表格支持 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 10. 定义型列表 名词 1 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 11. Html 标签 本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 12. 内嵌图标 本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 13. 待办事宜 Todo 列表 使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： [ ] Cmd Markdown 开发 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [ ] 支持以 PDF 格式导出文稿 [x] 新增Todo列表功能 语法参考 [x] 改进 LaTex 功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 语法参考 [ ] 七月旅行准备 [ ] 准备邮轮上需要携带的物品 [ ] 浏览日本免税店的物品 [x] 购买蓝宝石公主号七月一日的船票 这是一个 注脚 的 文本。 ↩︎","link":"/2020/01/Markdown%E8%AF%AD%E6%B3%95%E6%B5%8B%E8%AF%95/"},{"title":"源码阅读-HashMap","text":"HashMap的原理就是用一个数组存储一系列 k-v 结构的 Node 实体，存储的位置通过对 key 的 hashCode 进行计算得到，Node 对象因为有 next 指针，所以可以作为单链表的一个节点。如果发生 hash 冲突，就将新的 Node 插入链表里。链表过长超过阈值的话为了提高查询效率会转为红黑树（JDK 1.8以后）。 成员变量 123456789101112131415161718//默认初始化容量static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16//最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//默认负载因子 0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;//桶中链表树化的阈值 8static final int TREEIFY_THRESHOLD = 8;//树转为链表的阈值 6static final int UNTREEIFY_THRESHOLD = 6;//table最小树化容量 64static final int MIN_TREEIFY_CAPACITY = 64;//hashmap 中键值对的个数transient int size;//扩容阈值（容量×载因子）int threshold;//真正存放数据的地方transient Node&lt;K,V&gt;[] table; hashMap默认初始化长度是多少？为什么是这么多？ 默认初始化长度是 1&lt;&lt;&lt; 4，之所以不直接写16，是因为位运算比算术运算效率高，之所以选择16，是为了服务与 index 的计算公式 index = hash &amp; (length - 1)（这里采用与运算和取模的效果一样，但性能更好），初始化长度减1后为15，二进制位1111，和 hash 值运算后的结果等同于 hash 后几位的值，只要 hash 值本身分布均匀，那 hash 算法的结果就是均匀的，从而实现均匀分布。 为什么树化标准是8个？ 在源码注释中有提到：如果 hashCode 分布良好的话，很少出现链表比较长的情况。理想情况下，链表的长度符合泊松分布。各长度的概率如下 12345678910/* 0: 0.60653066 * 1: 0.30326533 * 2: 0.07581633 * 3: 0.01263606 * 4: 0.00157952 * 5: 0.00015795 * 6: 0.00001316 * 7: 0.00000094 * 8: 0.00000006 */ 当链表长度为8时，概率为0.00000006，概率非常小，红黑树的转换基本不会发生。当然也会有用到：用户使用自己的 hash 算法，导致 hashCode 分布离散很差，链表很长的情况。 为什么树退化为链表的阈值是6个？ 增加一个过渡，防止在临界值时增加/删除一个元素时，在树和链表之间频繁的转换，降低性能。 初始化方法 123456789101112131415161718192021222324252627// 最常用的一个，负载因子0.75public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted}// 指定初始化容量，负载因子0.75public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR);}// 指定初始化容量和负载因子public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; // 取二次幂里比指定容量大且最接近的一个，比如指定容量10，则输出16 this.threshold = tableSizeFor(initialCapacity);}// 将传入的map的键值对复制一份放hashmap里，不常用public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);} hash方法 hash() 方法是 HashMap 的核心方法，算出 key 的 hashCode 后，将算出的结果右移16位，与原 hashCode 按位异或得到 hash 后的值， 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 为什么要右移16位？ 让 hashCode 的高16位也参与运算，增加扰动，减少碰撞冲突，因为大部分元素的 hashCode 在低位是相同的。 相关问题：String的hashCode的实现？ 123456789101112public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h;} 简单来说就是给字符串的每一位，按位乘31的n次幂，再相加，用自然溢出来等效取模。选择31因为这个质数不大不小，且可以被虚拟机优化，运算效率更高。i*31 = i*(32-1) = i&lt;&lt;5-1 put方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public V put(K key, V value) { return putVal(hash(key), key, value, false, true);}final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // tab:引用当前HashMap的散列表 // p:表示当前散列表的元素 // n:当前散列表数组长度 // i:表示路由寻址结果 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 延迟初始化逻辑，第一次调用putVal方法时初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 找到的桶位为null,将key,valuef封装成node对象，放进去就ok if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; // 桶位中的元素与当前插入元素的key一致，后续会进行value的替换操作 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果桶位中的元素是红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { // 如果桶位中的元素是链表，且链表的头元素与要插入的之不一致 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 如果当前桶的元素计数大于等于树化阈值，则进行树化 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 找到一个元素与当前要插入的元素的key一致 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } // 找到了一致的元素，用新的value替换原来的value if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;} 在 putVal 方法中为什么要用 i = (n-1) &amp; hash 作为索引运算呢？ 这其实是种优化手段，由于数组的大小永远是一个2次幂，在扩容后，一个元素的新索引要么在原位置，要么在原位置+扩容前的容量。这个方法的巧妙处全在于&amp;运算，&amp;运算只会关注 n-1（n=数组长度）的有效位，当扩容后，n的有效位相比之前会多增加一位（n会变成之前的两倍，所以确保数组长度永远是2次幂很重要），然后只需要判断 hash 在新增的有效位的位置是 0 还是 1 就可以算出新的索引位置，如果是 0，如果是 2，索引就是原索引+扩容前的容量。 resize方法 resize()方法主要是用来扩容，具体操作是新建一个hash表，然后将旧表中的内容重新散列复制到新表中。源码主要分为2部分： 第一部分主要用于判断当前操作的类型（初始化or扩容）并且计算出新生成的表的容量和阈值。 第二部分只用于扩容操作时，将旧表中的元素重新散列放入新表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//扩容方法final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; // 引用扩容前的哈希表 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 扩容前table的容量 int oldThr = threshold; // 扩容前的阈值 int newCap, newThr = 0; if (oldCap &gt; 0) { // 扩容前table数组大小已达到最大值，则不扩容，且扩容条件设置为int最大值 if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 正常情况，新容量在老容量的基础上翻倍，则在阈值上也翻倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } // oldCap==0，oldThr&gt;0 说明哈希表中的散列表还未初始化，在使用带参构造的时候会发生 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; //oldCap==0，oldThr&gt;0 使用无参构造的时候 else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; // 说明当前桶位有数据 if ((e = oldTab[j]) != null) { // 方便JVM回收内存 oldTab[j] = null; // 当前桶位有一个元素，计算当前元素扩容后的位置 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 判断当前节点已经树化 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 当前是链表 else { // preserve order // 低位链表：扩容之后数组的下标位置与当前数组下标位置一致 Node&lt;K,V&gt; loHead = null, loTail = null; // 高位链表：扩容之后数组的下标位置 = 当前数组下标 + 扩容前数组长度 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; // 通过将hash值与 oldCap 相与，将原来的链表拆分为高位链、低位链 if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; //修改高位链表结尾 newTab[j + oldCap] = hiHead; //放进新table } } } } } return newTab;} get方法 get 方法逻辑比较简单，直接看注释 12345678910111213141516171819202122232425262728public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;}final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 第一种情况：定位出的桶元素即为要get的数据 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 第二种情况：当前桶位不只一个元素 if ((e = first.next) != null) { // 当前桶位上的为红黑树 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 当前桶位上是链表，依次匹配 do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null;} remove方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public V remove(Object key) { Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;}final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) { Node&lt;K,V&gt; node = null, e; K k; V v; // 当前桶位上的节点匹配一致 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { // 是树节点的情况 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); // 是链表的情况，遍历链表匹配 else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { // 匹配到的节点是树，用树的方法移除 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 如果就是当前桶位上的节点，用下一个节点直接覆盖 else if (node == p) tab[index] = node.next; // 匹配到的节点是链表，用链表的方法移除 else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null;}","link":"/2019/08/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-HashMap/"},{"title":"Linux上的OpenVPN搭建","text":"最近因工作需要搭一个VPN，网上查了查相关的词居然都被屏蔽（白眼.gif），只能自己鼓捣，记录一下过程。 1. 环境 1.1 硬件和网络拓扑 1.2 软件要求 2.安装配置 OpenVPN 服务端 2.1 配置 yum 源 2.1.1 配置 Centos 源 2.1.2 配置 EPEL 源 2.2 安装相关软件包 2.3 制作 server 端证书 2.4 配置 server 端配置文件 2.5 启动 server 端 2.6 设置 OpenVPN 开机自启（可选） 3. 安装配置 OpenVPN 的客户端 3.1 制作 client 端证书 3.2 client 端安装 3.3 制作 client 端配置文件 1. 环境 1.1 硬件和网络拓扑 OpenVPN Server：双网卡机器，同时连接大小网，提供 VPN 拨号服务。 OpenVPN Client：位于大网，通过拨号，获得小网地址后，可以和小网 PC 互相访问。 小网 PC：位于小网（如 192.168 网段） 注意：以下 OpenVPN Server 网络配置相关信息仅供参考，并非真实信息。 IP1：10.185.80.57 子网掩码1：255.255.254.0 IP2：192.168.18.6 子网掩码2：255.255.240.0 1.2 软件要求 操作系统：Centos 7 第三方包：所有软件包均通过 yum 在线安装 2.安装配置 OpenVPN 服务端 2.1 配置 yum 源 由于 rpm 包安装需要的依赖关系可能比较繁杂，这里选用 yum 在线安装。 2.1.1 配置 Centos 源 打开 Centos 清华镜像源 ，选择 Centos 7 配置文件，直接使用如下内容覆盖掉/etc/yum.repos.d/CentOS-Base.repo文件： 12345678910111213141516171819202122232425262728293031323334[base]name=CentOS-$releasever - Basebaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7#released updates[updates]name=CentOS-$releasever - Updatesbaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updatesenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7#additional packages that may be useful[extras]name=CentOS-$releasever - Extrasbaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extrasenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plusbaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplusgpgcheck=1enabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7 然后缓存元数据。 1yum makecache 2.1.2 配置 EPEL 源 openvpn 在 EPEL 仓库中，所以需要配置 EPEL 源。这里参考清华镜像源epel帮助，在/etc/yum.repos.d目录下增加“epel.repo”文件，内容如下： 1234567891011121314151617181920212223242526[epel]name=Extra Packages for Enterprise Linux 7 - $basearchbaseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/7/$basearch#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;arch=$basearchfailovermethod=priorityenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7[epel-debuginfo]name=Extra Packages for Enterprise Linux 7 - $basearch - Debugbaseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/7/$basearch/debug#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-7&amp;arch=$basearchfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7gpgcheck=1[epel-source]name=Extra Packages for Enterprise Linux 7 - $basearch - Sourcebaseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/7/SRPMS#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-source-7&amp;arch=$basearchfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7gpgcheck=1 然后执行下面的命令，缓存元数据。 1yum makecache 2.2 安装相关软件包 执行如下命令，一次性完成安装 1yum -y install lzo openssl easy-rsa openvpn 安装后，easy-rsa 的相关文件存放于/usr/share/easy-rsa/3.0.3和/usr/share/doc/easy-rsa-3.0.3两个路径下，需要把 easy-rsa 的相关文件放到一个目录，以便后面的操作， 这里我放到/root/EasyRSA-3.0.3/目录。操作如下 123mkdir /root/EasyRSA-3.0.3cp -a /usr/share/easy-rsa/3.0.3/* /root/EasyRSA-3.0.3cp -a /usr/share/doc/easy-rsa-3.0.3/* /root/EasyRSA-3.0.3 操作完成后，目录中的内容如下 2.3 制作 server 端证书 制作证书需要一个目录，（我这里以/etc/openvpn/目录为 server 端根目录)，执行 1234cp /root/EasyRSA-3.0.3 /etc/openvpn/ # 复制一份给server端，用于生成客户端证书cd /etc/openvpn/EasyRSA-3.0.3cp vars.example vars # 复制一份样例，准备修改vim vars # 修改样例 修改下 EasyRSA-3.0.3 目录下的 vars 这个文件，配置下环境变量，这里配置了主要是方便在后面制作证书的过程中不用输入很多信息，比较方便，我这里的配置如下图，业务可根据需求自行配置。 vars 这个文件修改完毕之后，需要 source 一下，再把证书系统初始化，操作如下 12source vars # 把var里面的值写入到环境变量中去./easyrsa init-pki # 初始化证书生成环境 下一步就是制作 CA 证书了，如下： 1./easyrsa build-ca # 制作ca证书 这里会要求出入一个 CA 证书的密码，可以不用输入，我这里输入的 CA 密码为 123456，同时设置 CA 的 Common Name 为 puma。 注意：这里CA的这个密码 123456 要记住，因为后续进行 server 证书和 client 证书认证的时候都需要输入这个密码的。如果忘记了的话，就需用重新制作根证书了。 下一步就是生成server端的证书了，执行： 1./easyrsa gen-req server nopass # 生成server端证书，需要输入server端的CommonName，可以自行设置 我这里配置的服务器的名字为 server，服务器证书的 Common Name 为 puma_server 接下来需要对服务器端的证书进行签名认证 1./easyrsa sign server server # 认证server端证书，需要前面设置的 CA 密码 注意：认证证书时需要输入CA的密码，我这里输入 123456，可以看到，认证成功了。 最后一步就是生成 Diffie-Hellman 文件了，如下： 1./easyrsa gen-dh # 生成 dh 证书 完成后如上图。到这里，server 端的证书和根证书就都生成了，我们把它们拷贝到一个目录下，方便后续 openvpn 的配置文件进行配置。这里把需要用到的证书都拷贝到 /etc/openvpn/server 目录下，操作如下： 123456cd /etc/openvpn/EasyRSA-3.0.3cp pki/ca.crt ../server/cp pki/issued/server.crt ../server/cp pki/private/server.key ../server/cp pki/dh.pem ../server/mv /etc/openvpn/server/dh.pem ../server/dh2048.pem # 根据vars文件中的设置，改名为dh2048.pem 执行完成后，/etc/openvpn/server目录下应该有4个文件 2.4 配置 server 端配置文件 执行如下命令写配置文件 12cd /etc/openvpn/server/vim server.conf # 创建 server 端配置文件并编辑，文件内容如下 12345678910111213141516171819202122232425# 强烈建议配置文件中用绝对路径port 1194 # 监听1194端口proto udp # 使用udp协议dev tun # 通信隧道类型为路由IP隧道ca /etc/openvpn/server/ca.crtcert /etc/openvpn/server/server.crtkey /etc/openvpn/server/server.keydh /etc/openvpn/server/dh2048.pem # 2048位密钥server 10.9.0.0 255.255.255.0 # 分配的ip地址区间ifconfig-pool-persist /etc/openvpn/server/ipp.txtpush &quot;route 192.168.16.0 255.255.240.0&quot; # 给客户端推送路由信息client-to-client # 客户端之间可以互相发现duplicate-cn # 开启证书复用keepalive 10 120comp-lzo # 启用lzo压缩算法persist-keypersist-tunstatus /etc/openvpn/server/openvpn-status.logverb 3 # 设置日志文件的冗余级别explicit-exit-notify 1 # 设置服务器重启时通知客户端，自动重新连接auth-user-pass-verify /etc/openvpn/server/checkpsw.sh via-env # 服务端认证;client-cert-not-required # 不要求客户端证书verify-client-cert # 要求客户端证书username-as-common-namescript-security 3 # 安全等级 3 上面的配置中我们把用户名密码校验交给了checkpsw.sh，现在写一个校验脚本 12cd /etc/openvpn/server/vim checkpsw.sh # 创建校验脚本，文件内容如下 1234567891011121314151617181920212223242526#!/bin/sh###########################################################PASSFILE=\"/etc/openvpn/server/psw-file\"LOG_FILE=\"/etc/openvpn/server/openvpn-password.log\"TIME_STAMP=`date \"+%Y-%m-%d %T\"`###########################################################if [ ! -r \"${PASSFILE}\" ]; then echo \"${TIME_STAMP}: Could not open password file \\\"${PASSFILE}\\\" for reading.\" &gt;&gt; ${LOG_FILE} exit 1fiCORRECT_PASSWORD=`awk '!/^;/&amp;&amp;!/^#/&amp;&amp;$1==\"'${username}'\"{print $2;exit}' ${PASSFILE}`if [ \"${CORRECT_PASSWORD}\" = \"\" ]; then echo \"${TIME_STAMP}: User does not exist: username=\\\"${username}\\\", password=\\\"${password}\\\".\" &gt;&gt; ${LOG_FILE} exit 1fiif [ \"${password}\" = \"${CORRECT_PASSWORD}\" ]; then echo \"${TIME_STAMP}: Successful authentication: username=\\\"${username}\\\".\" &gt;&gt; ${LOG_FILE} exit 0fiecho \"${TIME_STAMP}: Incorrect password: username=\\\"${username}\\\", password=\\\"${password}\\\".\" &gt;&gt; ${LOG_FILE}exit 1 保存后，给脚本加上可执行权限。接着编写 psw-file 文件，其中保存着已授权的用户名和密码。 12chmod +x checkpsw.shvim psw-file # 编写psw-file文件，内容如下 12用户名1 密码1用户名2 密码2 执行如下命令配置 iptables 的 NAT 转发 1iptables -t nat -A POSTROUTING -j MASQUERADE 在 openvpn-server 机器上，编辑/etc/sysctl.conf文件，加入net.ipv4.ip_forward=1到该文件中并保存，开启操作系统的网关转发功能，操作如下： 1vim /etc/sysctl.conf 修改完成并保存后就运行如下命令： 1sysctl -p # 使 /etc/sysctl.conf 配置文件里面的配置生效 2.5 启动 server 端 执行如下命令启动 openvpn 服务端，如图，表示启动成功。 1openvpn --config /etc/openvpn/server/server.conf 注意：OpenVPN 启动后会占用终端，按Ctrl+C停止运行。如果想启动后不占用终端，可加上--daemon参数，如此，启动命令则为：openvpn --daemon --config /etc/openvpn/server/server.conf 2.6 设置 OpenVPN 开机自启（可选） 服务端的安装配置到上一节就完了，为了避免服务器重启后需要手动开启 OpenVPN，这里将其设置为开机自启动，请根据需要选择。 进入到 /etc/rc.d/目录下，编辑 rc.local 文件，操作命令如下： 12cd /etc/rc.d/vim rc.local 在 rc.local 文件中新增下列内容 123456# OpenVPN startopenvpn --daemon --config /etc/openvpn/server/server.conf &gt; /dev/nullif [ $? -ne 0 ]then echo \"`date \"+%Y-%m-%d %H:%M:%S\"` start vpn failed in /etc/rc.d/rc.local\" &gt;&gt; /etc/openvpn/server/openvpn-status.logfi 保存后，修改系统时区和时间，使打印到日志中的时间和本地计算机的时间同步，执行操作： 12timedatectl set-timezone Asia/Shanghai # 设置时区为上海date -s 10:23:30 # 设置为自己本机时间 3. 安装配置 OpenVPN 的客户端 3.1 制作 client 端证书 client 端证书的制作过程和 server 端的相似，要注意 client 端制作证书的目录和 server 端并非同一个目录。我用来给client 端制作证书的目录：/root/EasyRSA-3.0.3，给server 端则是：/etc/openvpn/EasyRSA-3.0.3。 12cd /root/EasyRSA-3.0.3/ # 进入客户端证书制作目录./easyrsa init-pki # 初始化客户端证书制作目录 创建客户端证书，下面是创建成功的截图，client 的名字为 client_xushan，CommonName 为 puma_client_xushan 1./easyrsa gen-req client_xushan nopass # 生成client端证书，需要输入client端的CommonName，可自行设置，可设置密码 创建成功后，会在pki/reqs/目录下生成一个名为 client_xushan.req 的文件。 下一步就是在 server 端所在的目录里把上一步生成的 client_xushan.req 这个证书进行签约。 12cd /etc/openvpn/EasyRSA-3.0.3./easyrsa import-req /root/EasyRSA-3.0.3/pki/reqs/client_xushan.req client_xushan #导入客户端证书 客户端证书签约完成后，还需要进行最后一步的认证，认证之后就可以使用了，过程如下： 1./easyrsa sign client client_xushan # 认证客户端证书 到这里，客户端的证书就生成完成了，我们需要把他们拷贝到一个文件夹下，方便后续的使用，如下： 1234# 把客户端需要的文件统一放到 /etc/openvpn/client 下cp pki/ca.crt ../clientcp pki/issued/client_xushan.crt ../clientcp /root/EasyRSA-3.0.3/pki/private/client_xushan.key ../client 至此，client 目录下有3个文件ca.crt、client_xushan.crt、client_xushan.key，将 client 目录下载到本地（windows）。 3.2 client 端安装 客户端一般是 windows，组件全选安装。安装后桌面会有OpenVPN GUI的快捷方式。 3.3 制作 client 端配置文件 在本地（windows）创建 .ovpn的配置文件，名字随便起，这里我的是10.185.80.57.ovpn，配置信息： 123456789101112131415client # 表示当前是客户端dev tun # tun 模式（路由模式）proto udp # 使用 udp 协议remote 10.185.80.57 1194 # 服务器端的ip和端口resolv-retry infinite # 断后尝试重连nobindpersist-keypersist-tunca ca.crtcert client.crtkey client.keyauth-user-pass # 密码认证remote-cert-tls servercomp-lzo # 启用lzo压缩算法，与server端保持一致verb 3 根据配置文件，修改client_xushan.crt文件名为client.crt、修改client_xushan.key文件名为client.key保存后，放到刚下载的 client 文件夹下，把 client 文件夹改名成10.185.80.57。将整个文件夹放在 OpenVPN的安装目录下的 config 文件夹下，启动客户端，选择当前配置，输入用户名和密码后会连接上（必须在 server 端中已授权），如图，连接成功 【可选配置】 如不想经常输入用户名和密码，可打开客户端ovpn配置文件，将auth-user-pass改成auth-user-pass pass.txt。同时在相同路径下新增一个名为pass.txt的文本文件。 内容为两行，第一行为 VPN 用户名，第二行为密码。 重新运行 OpenVPN 客户端，即可不输入密码登录 VPN 了！ 参考： 完整CentOS搭建OpenVPN服务环境图文教程.老左博客","link":"/2019/02/Linux%E4%B8%8A%E7%9A%84OpenVPN%E6%90%AD%E5%BB%BA/"},{"title":"Git笔记","text":"实践中发现版本控制还是很重要的，于是看了看廖雪峰的Git教程，比较简单易懂，整理一下笔记。 Git简介 Git的诞生 集中式vs分布式 安装Git 在Linux上安装Git 在Debian系上用sudo apt-get install git就可以。 安装完成后，还需要最后一步，在命令行中输入： 12git config --global user.name \"Your Name\"git config --global user.email \"email@example.com\" 创建版本库 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分为两步： 第一步，使用git add &lt;file&gt;，可反复使用多次，添加多个文件； 第二步，使用命令git commit -m &quot;注释&quot;，完成 时光穿梭机 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容 版本回退 HEAD指向的版本就是当前版本，上一个版本是HEAD^，上上一个版本是HEAD^^。Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。如果嫌输出信息太多，可以试试git log --pretty=oneline 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区 git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。例如git commit -m &quot;&lt;修改的内容&gt;&quot; 管理修改 用git diff HEAD -- file查看工作区的版本库里最新版的区别 撤销修改 场景1：当改乱了工作区某个文件的内容 想直接丢弃工作区的修改时，可以用git checkout -- file。 场景2：改乱的工作区文件已经添加到了暂存区，想丢弃，先用命令git reset HEAD file可以把暂存区的修改撤销掉（unstaged），重新放回工作区；然后用git checkout -- file。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退部分，前提时没有推送到远程仓库。 删除文件 用git rm file来删除一个文件。 远程仓库 前提：已注册Github 第1步：创建SSH Key。ssh-keygen -t rsa -C &quot;youremail@example.com&quot;,修建地址换为自己的邮箱地址，回车，yes。正常的话会看到用户主目录下的.ssh目录下找到id_rsa私钥，id_rsa.pub公钥。 第2步：打开Github的设置，增加SSH Key，填上id_rsa.pub文件里的内容。OK！ 添加远程仓库 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支所有内容； 此后，每次提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本控制系统的最大好处之一是有没有联网都可以正常工作，有网的时候推送一下就同步了。 从远程仓库克隆 要克隆一个仓库，首先必须只当仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但是通过ssh支持的原生git协议速度最快。 分支管理 创建与合并分支 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 解决冲突 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log --graph命令可以看到分支合并图。 分支管理策略 Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并后就看不出来曾经做过合并。 BUG分支 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没完成时，先把工作现场git stash一下，然后去修复bug，修复后再git stash pop，恢复现场，恢复的同时也把stash内容删了。 当多次stash，恢复的时候，先用git stash list查看，然后恢复制定的stash，用命令git stash apply stash@{0}，stash@{0}是查看stash list时那次stash的码。 Feature分支 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强制删除。 多人协作 多人协作的工作模式通常如下： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示“no tracking infomation”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream &lt;branch-name&gt; origin/&lt;branch-name&gt;。 查看远程库信息，使用git remote -v； 本地分支如果不推送到远程，对其他人就是不可见的； 标签管理 创建标签 命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a &lt;tagname&gt; -m &quot;balabala...&quot;可以指定标签信息； git tag -s &lt;tagname&gt; -m &quot;balabala...&quot;可以用PGP签名标签； 命令git tag可以查看所有标签。 操作标签 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签； 使用Github 在Github上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码。 使用码云 码云和Github的使用方法差不多，具体参考上一节使用Github； 因为众所周知的原因Github访问速度比较感人，But码云不会，并且是国内的； 有免费的私有仓库，And支持中文，简直是我等英语渣渣的福音； 本地库与多个远程库关联，嗯，不想说了，直接看廖雪峰Git教程这一节吧。 自定义Git 忽略特殊文件 编写.gitignore文件，把要忽略的文件名填进去，Git就会自动忽略这些文件。https://github.com/github/gitignore 上的稍微改一下就可以用了 .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理 忽略文件的原则： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等； 忽略带有自己敏感信息的配置文件； 配置别名 git config --global alias.st status表示用st作为status的别名，以后敲git st就可以了 12345git config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br brachgit config --global alias.last 'log -1' //用`git last`显示最后一次提的交git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\" //查看提交历史，丧心病狂版 搭建Git服务器 搭建Git服务器，参考教程原文； 要方便管理公钥，用Gitosis； 要像SVN那样变态控制权限，用Gitolite；","link":"/2017/05/Git%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"开箱","slug":"开箱","link":"/tags/%E5%BC%80%E7%AE%B1/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"源码阅读","slug":"源码阅读","link":"/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"categories":[]}